# step1

## 진행 사항
1. 기본 마크업
    -   이번 주 미션이 진행되는 헤더부분과 캐로셀 부분 마크업 작업을 먼저 진행했습니다. index.html에 우선 뼈대 작성 후 컴포넌트 JS파일을 만들면 index.html에서 지워주는 순서로 작업 중입니다.
2. carousel 기능 구현
    -   캐로셀을 지난 카카오 미션 때 해봤었기 때문에 익숙하여 먼저 구현했습니다...만 결과적으로 카카오 때와는 동작방식이 달라 새롭게 코드를 작성했습니다.
    -   썸네일에 마우스오버시 오토슬라이드를 정지하였는데 UX를 고려하면 썸네일이 아닌 캐로셀에 마우스가 올라오면 정지하는 것이 바람직할 것 같습니다.

## 고민한 부분, 어려웠던 점
1. scss
    -   scss를 처음 사용했는데 익숙치가 않아 좋다는 느낌을 많이 받지 못했습니다. mixin 기능을 사용해보고 싶은데 아직 적용하지 못했습니다. 
    -   scss로 중첩을 쉽게할수 있는 것은 좋은데 오히려 indent가 너무 깊어지는 상황(_header.scss)이 발생했습니다. 
    잘하시는 분들이 어떻게 하셨나 참고할 필요가 있을 것 
    같습니다.

2. class의 Private 속성
    -   함수로 모듈을 구성할 때는 export로 원하는 함수만 공개할 수 있었기 때문에 class에서는 어떤 식으로 원하는 것만 노출시킬까 찾아보다가 # prefix로 private 속성을 적용해 보았습니다.
    -   사용자가 함부로 내부 로직에 영향을 줄 수 없게 한다는 점에서 좋은 것 같긴한데.. 혼자하는 초소형 프로젝트라 직접적으로 유용함을 느끼진 못했습니다. 약간 마음이 편안해지는 효과..?

3. 오토슬라이드 멈추기
    -   지난 카카오 미션에서 슬라이드 위로 마우스를 여러번 올리고 내리면 eventListener가 여러번 호출되어 슬라이드를 넘기는 timeInterval이 여러개 생겨 한번에 여러장이 넘어가는 버그가 있었습니다.
    -   이번엔 클래스를 이용하기 때문에 전역변수 없이 intervalID를 저장하고 이미 수행중인 것이 있으면 재등록하지 않는 방식으로 문제를 해결했습니다...
    -   ...만 어쨌든 이벤트처리 자체는 여러번 수행하는 것이기 때문에 근본적으로 이벤트가 중복발생하지 않도록 하는  방법을 생각해봐야겠습니다. 

## 이후 계획
원래는 익숙한 캐로셀을 후딱 구현하고 이번 주의 핵심인 검색창 부분을 prototype을 사용하여 구현할 계획이었는데 시간이 생각보다 오래걸렸습니다...

    0. 이번 PR의 리뷰 반영
    1. prototype 학습 및 적용
    2. 검색창 부분 미션 구현
    3. scss 리팩토링

순으로 다음 PR까지 진행하려 합니다. 


# step2

## 기능 구현 목록

### 검색 카테고리
-   [x] 클릭시 카테고리 펼쳐지기(애니메이션)
-   [x] 카테고리 목록 클릭시 해당 카테고리를 상단에 등록
-   [ ] 키보드로 조작

### 최근 검색어
-   [x] 입력창 선택시 최근검색어창 열기
-   [x] submit시 최근검색에 등록
-   [x] 전체삭제기능
-   [x] 최근 검색어 클릭시 입력창에 반영
-   [ ] 최근검색어끄기 기능
-   [ ] 키보드로 조작

### 자동완성
-   [x] 검색어 입력시 자동완성 기능 시작
-   [x] 500ms debounce
-   [x] 아마존 자동완성 서버로부터 데이터 fetch
-   [ ] 키보드로 조작
-   [ ] 추천 검색어 클릭시 입력창에 반영

## 캐로셀
-   [x] 자동 화면 전환
-   [x] 썸네일에 mouse hover시 전환
-   [ ] 썸네일 이벤트에 debounce 걸기
  
## 프로그래밍 요구사항 수행 목록
-   [x] ES Classes 기반 객체를 한 개 이상 만든다
-   [x] prototype 기반 객체를 한 개 이상 만든다. --> renderer에만 적용...
-   [x] 검색창 관련된 모듈을 하나의 객체로 하지 않고 여러개의(2개이상) 객체로 나눠서 개발
-   [x] 컴포넌트 나눠 상속 받아 사용 --> dropdown class 상속받아 사용
-   [ ] scss 중첩 및 mixin 사용 --> 일부에만 적용. 리팩토링 필요
-   [ ] prototype 사용한 상속 



## 구현하며 신경쓴 점 (의도)

1. 전반적인 구현 과정
    -   지난 미션까지는 구조 설계나 컴포넌트 나누는 것에 시간을 많이 썼습니다. 이번에도 역시 그렇게 시작했으나 고민을 계속한다고 해서 깔끔한 정답을 얻기에는 아직 실력이 부족하다고 생각해서 이번에는 방식을 바꿔봤습니다. 
    -   큰 틀에서 구현해야하는 기능을 꼬리를 물며 정리했고 필요한 함수 목록을 이름만 먼저 작성한 뒤 구조를 나누지 않고 일단 코드를 작성했습니다.
    -   그 이후 중복되는 부분이 발생하거나 하나의 클래스가 너무 많은 역할을 한다고 생각될 때 분리하여 새로운 하위 컴포넌트를 정의했습니다.
    -   그렇게하다보니 Search에서 SearchCategory와 SearchMain이 분리되고, SearchMain에서 필요한 기능을 RecentSearchList와 AutoComplete로 꺼내 따로 정의하게 되었습니다.
    -   장점(느낌)
        -   직접 필요를 느끼며 구조를 만든 것이라서 나름의 논리가 생겨 뒤로 갈수록 코드 짜는것이 수월했습니다. 
        -   이전에는 분명 제가 짠 코드인데 '어? 이 함수 어디다 뒀더라' 하던 때도 있었는데 이번에는 있을만한 곳에 가보면 그 함수가 있는 느낌... 
    -   단점
        -   더 좋은 방법을 찾으려면 나름대로 노력했는데도 문제가 있음을 깨닫고 다른 사람은 어떻게 했는지 찾아야합니다. 재밌고 좋은 학습법이라고 생각하지만 패턴을 공부하고 '정석'대로 짜려할 때보다 오래걸리는 것 같습니다.
        -   필요를 느낄 때마다 분리하다보니 일을 두 번하는 느낌도 들고, 덜 나눠진 부분들이 존재합니다.  

2. 모듈이란?
    -   '위 방법대로 구현하면서 모듈이란 무엇일까?' '어떻게 모듈을 나누고 정의해야할까?'를 고민했습니다.
    -   이번 미션을 진행하며 모듈은 커다란 공동 목표를 위해 모인 회사원과 비슷하다고 느꼈습니다.
    
    1. 각 모듈(회사원)은 적절한 양의 명확한 역할을 맡아야한다.
    2. 상위 모듈(간부)는 하위 모듈(부하)의 세세한 동작을 알거나 지시할 필요없이 큰 틀에서 작업을 명령해야(할수 있어야)한다.
        -   상위 모듈의 역할은 data를 받아와 class에 넘겨줌으로서 instacne를 정의하고 작업지시는 instance.template, instance.activate()등으로 큰틀에서만 진행.
    3. 단, 하위모듈(팀)에 속한 모듈(팀원)들끼리는 보다 많은 것을 공유할 수도 있다.
        -   서로 정보를 주고받아야하는 부분이 있으므로 최상위에게 getTemplate(), activate()만 오픈하는 것에 비하면 많은 동작을 서로 공유한다.
        -   그렇다하더라도 최대한 필요한 부분만 노출하고 내부 작업은 숨긴다.
    
3. Private
    -   위와 같이 나름 정의한 모듈을 만들기 위해class의 Private 기능을 일부러 사용했습니다.
    -   이 모듈이 마땅히 수행해야하는 동작을 먼저 생각해 본 후 public method로 이름지은 후 내부 동작은 전부 private으로 구현했습니다.
    -   그렇게 모듈을 만들어 사용하는 중 public으로 제공하는 것 외에 내부 사정을 건드리고 싶어지는 상황이 발생하면...
        1. 사용하는 곳과 사용 중인 모듈의 역할이 명확하게 나뉘지 않아서 서로 내부 사정을 들여다보고 싶은 것이다.
        2. 사용 중인 모듈의 역할 정의가 명확하지 않았다.
    -   위 둘중에 하나라고 생각하여, 잠시 멈추고 모듈의 역할을 다시 정리했습니다.

## 정리
위 사항들은 처음부터 정리되어 코드를 작성할 때 반영된 것이 아니고, 코드를 작성하다보니 '이러이러한 원칙들을 지킬 필요가 있겠구나..'라고 느낀 것을 정리한 것입니다. 그래서 실제 코드에는 완벽히 지켜지지 못했습니다. 위 내용은 이번 일주일동안 들었던 생각이기 때문에 앞으로 다른 사람들 코드도 많이 보고 토론도 하며 생각을 발전시켜봐야겠습니다. 이번주에 핵심 주제 중 하나였던 prototype 또한 코드에 많이 사용하지 못해 주말동안엔 prototype을 좀 더 공부해볼 예정입니다.

감사합니다! 

# step3

## 기능 구현 목록

### 카테고리 메뉴
-   [x] 카테고리 버튼에 마우스 올리면/내리면 메뉴 등장/숨김
-   [x] 1차메뉴에 마우스 올리면 그에 맞는 2차메뉴 등장
-   [x] 1차메뉴에서 2차메뉴로 이동시 대각선 이동 지원(smart menu layer) --> 버그 존재
-   [ ] 레이아웃 css 작업
-   [ ] 3차 메뉴 구현

### 검색창 (지난주 요구사항)
-   [x] 키보드로 조작 --> 위아래 방향키로 검색어 이동가능
-   [ ] 최근검색어끄기 기능

## 프로그래밍 요구사항 수행 목록
-   [x] 스마트 메뉴 레이어는 setTimeout을 잘 활용해서 debounce 나 throttling 방식을 사용한다
-   [x] Store를 View영역에서 분리한다. (Category 한정)
-   [ ] 지난 주에 구현한 컴포넌트 파일에서 store와 view를 분리. 단 나만의 철학을 지키며. 

## Smart Menu Layer (UX)

### 개요

-   스마트 메뉴 레이어는 1차 레이어에서 2차 레이어로 마우스 이동시 레이어 칸을 벗어나지 않게 수직으로 이동할 필요 없이 대각선 이동을 지원하는 것. (참고 사이트 : https://story.pxd.co.kr/655 )
-   기존의 쿠팡 카테고리에는 이 기능이 '일부' 적용되어 있었다!
    -   1차 레이어에서 2차 레이어로 북동쪽 방향으로 커서를 이동하면 스마트 레이어 기능이 적용되어 다른 2차 레이어로의 전환없이 원하는 레이어에 도달할 수 있었다.
    -   그런데 남동쪽 방향으로 커서를 이동할 때는 스마트레이어 기능이 없어 수평방향으로 잘 움직여야 원하는 레이어로 이동가능하다.
    -   도대체 왜 이렇게 해놨을까? 깜빡한걸까?

### 구현 방법
1. Debounce
    -   mouse event에 debounce를 걸어 이벤트가 계속 발생하고 있을 때는 반영(2차 레이어 render)하지 않다가 이벤트 발생이 더 이상 없을 때 반영해주는 방법을 생각해 보았습니다.
    -   이 방법은 1차 레이어에서 2차 레이어 쪽으로 대각선 이동할 때는 유용하게 작동하지만, 1차 레이어안에서 마우스를 움직일 때는 불필요한 지연이 발생해 나쁜 UX를 줄수 있다고 생각했습니다.

2. 마우스 방향 감지
    -   크롱이 아마존에서 이런 방식을 사용했다고 하셔서 방식을 따라해봤습니다.
    -   펼쳐져 있는 2차 레이어의 상하단 끝점과 기존 커서 위치를 이용해 삼각형을 만들고 이동한 커서가 삼각형 안에 있으면 해당 2차레이어로 이동하고 있다고 판단합니다.
    -   위와 같이 판단시에는 마우스가 이동한 1차 메뉴의 2차 레이어를 바로 render하지 않고 delay를 줍니다.
    -   delay 이내에 2차 레이어로 이동하면 대기 중이던 render를 취소하고, 여전히 1차 레이어에 머물고 있다면 해당 1차 메뉴에 맞는 2차 레이어를 render해줍니다.

### 구현 결과

(동영상)

현재 삼각형 밖으로 커서를 이동시켰는데도 가끔 삼각형 안으로 계산하여 delay가 적용되는 버그가 있습니다. 2차원에서 벡터 외적과 삼각형 내부 판별을 간이로 수행했기 때문에 발생한 버그인지, 로직 순서상의 버그인지 아직 모르겠습니다. 시간이 되면 버그를 찾아보려 합니다. 

## Model - View 분리

    지난주에 작성했던 components 파일들을 먼저 리팩토링하는 대신 이번주에 새롭게 구현한 Category 기능을 Model View 그리고 Category로 나눠서 작성해봤습니다.

### 1. Model
    -   필요한 data를 fetch
    -   data를 분석하여 정리
    -   다른 데이터를 가져가 사용할 수 있게 호출 API 제공

Category의 경우 Model의 역할이 많지 않았습니다. 사실 서버에서 데이터를 제공하는 형태가 조금만 잘 정리되어 있었더라면 Model을 굳이 따로 둘 필요 없이 필요한 데이터를 바로 fetch받아와 사용해도 될것 같다는 생각이 들었습니다. (그래서 이번엔 일부러 서버의 json에는 그냥 데이터를 뭉쳐두고 Model에서 parse라도 하게 역할을 줬습니다.)

지난 주에 구현했던 다른 컴포넌트들도 Search data를 추가 제거하며 관리해야하는 RecentSearchList를 제외하고는 Model이 할일이 별로 없을 것 같아 '굳이 나눠야 하는가?'라는 고민을 하고 있습니다. 

### 2. View
    -   제공 받은 data를 사용해 적절한 DOM template를 생성

Model에 대한 의존성을 없애기 위해 View는 Model을 알지 못하게 했습니다. 그래서 event 발생에 따라 다른 data를 이용해 view를 render해야하는 경우 해당 event 처리는 전부 controller에서 해줬습니다. 그랬더니 View 또한 역할이 굉장히 컴팩트 해졌습니다. 반대급부로 Controller가 커졌기 때문에 data와 관계없는 event(ex. 마우스가 떠나면 카테고리 메뉴 접기)들은 view에서 처리해줘도 되겠다는 생각을 했습니다.

### 3. Controller
    -   사용자 입력을 접수하고 반응
    -   model에서 데이터 요청하여 view에게 제공, view로부터 전달받은 template를 DOM tree에 등록

데이터 관리와 template 생성을 제외한 모든 역할을 맡았습니다.
위에 설명한대로 controller의 역할이 너무 많아 가독성이 떨어지는 것 같습니다. 일부를 view에게 넘기거나, controller를 분리하고 싶다는 생각을 했습니다.

# step3

이번 PR에도 새로운 코드 작성은 많지 않고 고민한 것과 그것을 어떤 식으로 해결하고자 했는지에 대하여 정리해보았습니다. 본의아니게 길이 글어졌네요....ㅠㅠ

## 이런 코드가 작성되기까지의 여정

## 0. 이번 코드 작성의 목적

Model과 View를 분리하는 것이 이번주 미션의 핵심이기 때문에 MV* 패턴을 적용해보고자 했으나, 
-   현재 작성 중인 코드는 패턴을 통해 복잡도를 낮춰야할만큼복잡하지 않음. 
-   많은 기능이 model을 굳이 client에 구현해 관리할 필요 없이 server에서 잘 정리된 데이터를 fetch받아오는 것만으로도 구현가능.

위와 같이 상황을 판단했기 때문에 패턴을 적용하는 것이 오히려 로직을 복잡하게 만드는 것 같았습니다. 그래서 이번 코드를 작성하는 동안 전체 코드가 이보다 복잡하고, 재사용을 적극적으로 해야하는 경우를 가정했습니다.

지난 주에 만든 Component들은 다른 component와의 의존성은 없지만, 안에서는 데이터 처리, render, 이벤트 처리 등의 로직들이 한 덩어리로 얽혀 있었기 때문에 일부 로직을 다른 비슷한 component에서 사용하고 싶더라도 분리하는 것이 어려웠습니다.

그래서 view 또는 model을 전체 로직에서 분리하여 다른 component에서 동작 방식은 다르더라도 같은 view 혹은 model을 재사용할 수 있게 하는 것이 목표였습니다.

## 1. 처음 정의한 Model, View, Controller 의 역할

처음 정리한 MVC의 각 역할은 다음과 같았습니다. (지난 수업과 PR 리뷰를 바탕으로)

### 1. Model
    -   필요한 데이터를 보관하고 분석하여 알맞게 내어주는 역할.
    -   View나 Controller를 알 필요 없음.
    -   Controller가 데이터를 요청하면 줄수 있게 API만 제공하면 됨.

### 2. View
    -   화면에 데이터를 알맞게 표시해주는 역할.
    -   사용자의 입력을 받아 필요한 로직에 연결시키는 역할.
    -   입력을 받으면 Controller에게 처리를 요청하거나, Model에서 필요한 데이터를 받아와 Render하여 화면에 반영.
    -   controller와 model을 알고 있음.

### 3. Controller
    -   View가 요청한 로직을 수행.
    -   이벤트에 따라 Model을 조작할 수도 있고 Controller 자체적으로 view의 요청을 처리후 View에게 결과를 알려줌. 
    -   그 뒤의 render에는 관여하지 않음.

위와 같이 컴포넌트 내의 역할을 분리하자. 책임이 보다 명확해져 디버깅이 쉬워지고 다른 컴포넌트에서 render하는 로직이나 데이터 관련 로직을 재사용하기 보다 용이해진 것 같았습니다. 

## 2. 위 방법의 문제

위와 같이 역할을 정의하고 구현 중에 몇가지 문제가 보였습니다.
    
### 문제 1. View가 Model을 굳이 알아야하나?     

    발생한 이벤트에 따라 view가 직접 model을 호출해 필요한 데이터를 호출하는 방법은 코드 작성은 단순해서 쉬울 수 있지만 View를 다른 Model이 있는 곳에서 재사용할 때 View를 그대로 사용하지 못하고 해당 Model에 맞게 수정해줘야 합니다.

### 해결 1. Model은 Controller로만 조작

    위 문제는 View가 Model에 직접 접근하지말고 항상 Controller를 통해 Model의 data를 제공받는 방식으로 수정하여 해결할 수 있다고 생각했습니다.

### 문제 2. View가 Controller의 처리 결과를 예상하고 기대해야한다.
    
    사실, 문제1의 경우 Model이 항상 일관된 API를 제공하면 View가 Model에서 직접 필요한 데이터를 가져오는 것도 크게 문제는 아니라고 생각했습니다.

    반면, 문제2의 경우 View가 event의 처리를 controller에게 위임하더라도 controller가 처리 결과를 view에서 받아 view가 화면을 바꿔야한다면 view는 controller가 어떤 식으로 이벤트를 처리할지 어렴풋이라도 알고 있어야합니다. (ex-이벤트 처리후 return이 항상 있는지, 이 이벤트의 처리 결과가 어떤 데이터인지 등..)

    그렇다는 말은 view에 다른 controller를 붙여 재사용하는 경우, controller가 이벤트를 처리하는 방식이 다르다면 이후의 view의 후속 처리 로직도 달라져야합니다. 

### 해결 2. View는 Controller에게 추상적으로 처리 요청만 보내고 끝!

    위 문제를 해결하기 위해서는 view가 이벤트 처리를 controller에게 요청한 뒤 그 후속 처리에 관해서는 관심을 끌 수 있어야합니다. 그럼 어떻게 처리 결과를 view에게 알릴 수 있을까 고민하다가 state와 Observer라는 객체를 사용하기로 했습니다.
    
    controller는 요청받은 이벤트를 비즈니스 로직에 맞게 처리하고 그 결과를 state에 업데이트 합니다. 여기서 state란 화면에 보여지는 상태를 말합니다. 즉 controller의 역할이 단순히 로직을 처리하고 결과를 뱉어주는 것이 아니라 로직을 처리하고 view에 보여질 상태를 저장하는 것으로 바뀌었기 때문에 view-model이라고 부를 수 있을 것 같습니다. 

    state가 변경되면 그 사실을 view에게 공표해야합니다. 그것을 Observer를 통해 수행합니다. 그게 언제가 되었든 view-model의 state가 변경되면 observer를 통해 그 사실을 view가 알게되고 그것을 반영해 view를 수정하는 것입니다.

## 3. 최종적으로 적용한 방법과 그 장단점

위의 해결방안을 적용한 결과를 정리하면 다음과 같습니다.

### 1. View
    -   이벤트 발생시 그냥 view-model에 이벤트 발생했다고 알려줌.
    (단, UI상 처리해야하는 로직이 있다면 view에서 해결)
    -   view-model한테 구체적으로 ~~해줘 하는 것이 아니라 그냥 handleThisEvent() 처럼 대충 전달만.   
    -   view-model에 알린 후 view는 아무 생각이 없음....
    -   그러다 화면 바꾸라는 공지(observer의 notify)가 오면 묻지도 따지지도 않고 그냥 화면 그려줌.

### 2. View-model
    -   특정 이벤트 발생시 처리해야하는 로직을 갖고 있음.
    -   수행 후 화면 변경이 필요하면 state에 등록하고 공지만 날림.
    -   해당 이벤트가 어디서 왔는지, 처리 결과가 어떻게 될건지 관심 없음.

### 장단점 (느낌)
    장점 : view, view-model, model이 다 자기 일밖에 모르는 바보가 됨. 다른 V/MV/M과 결합하더라도 신경쓸 것 없이 늘상 하던대로 자기 일만하면 됨.

    단점: 완전히 분리된 것이라고 할수 있을까? 희미한 의존성은 있음.
    view는 view-model이 언제 state를 변경하는지는 관심을 꺼도 되지만 어떤 형태의 state가 오는지는 알아야함. 따라서 view를 재사용하는 view-model들은 일관된 state를 제공해야 함.
    --> 이것마저도 해결가능한 방법이 있을까?

## 질문

제가 의도한대로 코드가 작성되었을까요..? 열심히 고민하고 해결방안을 적용해보긴했는데 확신이 들지 않아 우선 Category에만 MVVM(?)을 적용했습니다. 피드백 받은 후 다음 주에 다른 컴포넌트들에도 적용해볼 예정입니다.